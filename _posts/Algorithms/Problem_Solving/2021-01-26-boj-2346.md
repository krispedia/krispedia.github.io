---
layout: post
title: "[BOJ] 2346. 풍선 터뜨리기"
categories: problem-solving
tag : [boj, cpp]
---

## 문제 링크<br>
 [https://www.acmicpc.net/problem/2346](https://www.acmicpc.net/problem/2346)<br>


#### 전체코드<br>

<details>
<summary>맞은 코드 보기 - STL</summary>
<div markdown="1">

```cpp
#include<iostream>
#include<list>

using namespace std;

//PARAM: ballons pair<idx, term>
void solution(list<pair<int,int>> ballons){
    while(!ballons.empty()){
        auto target = ballons.begin();
        cout<<target->first<<" ";
        ballons.pop_front();
        if(ballons.empty()) break;

        int term = target->second;
        if(term>0){
            term--;
            while(term--){
                auto sub = ballons.front();
                ballons.pop_front();
                ballons.push_back(sub);
            }
        }
        else{
            while(term++){
                auto sub = ballons.back();
                ballons.pop_back();
                ballons.push_front(sub);
            }
        }
    }
}
int main(){
    ios_base::sync_with_stdio(false);
	cin.tie(NULL);

    int n; cin>>n;
    list<pair<int,int>> ballons;
    for(int idx=1; idx<=n; idx++){
        int num; cin>>num;
        ballons.push_back(make_pair(idx,num));
    }
    solution(ballons);

    return 0;
}
```
</div>
</details>

<details>
<summary>맞은 코드 보기 - 직접 구현</summary>
<div markdown="1">

```cpp
#include <iostream>
using namespace std;

typedef struct listNode{
    int index;
    int data;
    struct listNode* prev;
    struct listNode* next;
} ListNode;

class LinkedList{
public:
    ListNode* head;
    ListNode* tail;
    int n;

    LinkedList(){
        head = NULL;
        tail = NULL;
        n=0;
    }

    void add_node(int num){
        n++;
        ListNode* new_node = new ListNode;
        new_node->index = n;
        new_node->data = num;
        new_node->prev = NULL;
        new_node->next = NULL;

        if(head == NULL){
            head = new_node;
            tail = new_node;
            return;
        }
        tail->next = new_node;
        new_node->prev = tail;
        new_node->next = head;
        tail = new_node;
        return;
    }
    void print_list(){
        ListNode* p = head;
        for(int i=0; i<n; i++){
            //cout<<'['<<p->index<<']';
            cout<<p->data<<' ';
            p = p->next;
        }
    }
    void erase_node(ListNode* target){
        ListNode* front = target->prev;
        front->next = target->next;
        target->next->prev = front;
        n--;
    }
    ListNode* move(ListNode* cur, int step){
        ListNode* target = cur;

        cout<<target->index<<' ';
        erase_node(target);

        if(n==0){
            target = cur;
        }
        else{
            if(step>0) {
                for (int i = 0; i < step; i++) {
                    target = target->next;
                }
            }
            else{
                step *= -1;
                for (int i = 0; i < step; i++) {
                    target = target->prev;
                }
            }
        }
        return target;
    }
};


int main() {
    LinkedList ll;
    int n;
    cin>>n;

    for(int i=0; i<n; i++){
        int x;
        cin>>x;
        ll.add_node(x);
    }
    ListNode* p = ll.head;
    ll.head->prev = ll.tail;

    while(ll.n != 0){
        p = ll.move(p, p->data);
    }

    return 0;
}
```
</div>
</details>

#### 결과 성공!<br>
![]()

<div class="divider"></div>

#### 주의 <br> 

## 풀이<br>
이 문제는 풍선을 list에 넣어 동작하도록 하면 된다.<br>

C++ STL의 list를 사용해도 되고 직접 구현해도 된다.<br>

백준 체점을 기준으로 직접 구현한 경우가 메모리와 시간이 적게 들었다.<br>


